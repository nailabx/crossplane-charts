# Argo appset
The goal of this appset is to be able to deploy as many helm as possible by using argo appset generators.
It scan the values file and generate a application for each dependecies.

## Values format
```yaml
global: {} # this will be injected accross all the appset chart generated by generators
dependencies: # these are the list of chart with want the generator to generate appset 
    service-a: # this is a service
        name: service-b # name of the service
        kind: stateless | stateful | job | crossplane(for crossplane resource)
        version: 0.1.0 # the version of the chart to use to deploy the serviceA
        values: {} #list of values to be injected to the chart been deployed for the servicea
        valueFiles: [] # list of file been been use as values file for the chart been for servicea deployed
        valueFilesGit: "" #if the values file is located in another git repo
    service-b: # this is a service
        name: service-b # name of the service
        kind: stateless | stateful | job | crossplane(for crossplane resource)
        version: 0.1.0 # the version of the chart to use to deploy the serviceA
        values: {} #list of values to be injected to the chart been deployed for the servicea
        valueFiles: [] # list of file been been use as values file for the chart been for servicea deployed
        valueFilesGit: "" #if the values file is located in another git repo
    service-c: # this is a service
        name: service-c # name of the service
        kind: stateless | stateful | job | crossplane(for crossplane resource)
        version: 0.1.0 # the version of the chart to use to deploy the serviceA
        values: {} #list of values to be injected to the chart been deployed for the servicea
        valueFiles: [] # list of file been been use as values file for the chart been for servicea deployed
        valueFilesGit: "" #if the values file is located in another git repo
```
## How does it work?
Each application is consider as one single file with an id. 123-todoapp.yaml.
That file is used to have all it dependencies. Like the todoapp can be a stateless app to be deployed into kubernetes, it maybe need an aws elasticache redis, it may need an rds, or secret, and so on.
So the values file will look something like this.
so the 123-todoapp.yaml will look like this
```yaml
global:
    labels: {}
    annotations: {}
    assetID: ""
    owner: {}
    clusterName: ""
    namespace: ""
    project: "" #the argo project to use
dependencies: 
    todo-app:
        name: todo-app
        kind: stateless 
        version: 0.1.0 
        values: 
            replicatset: 3
            strategy: "bluegreen"
            labels: {}
            annotations: {}
        valueFiles: 
            - /location/to/the/value/file/in/the/gitop/repo
        valueFilesGit: "giturl if the repo is not same as where the code is"
    todo-app-s3:
        name: todo-app-s3-bucket
        kind: crossplane 
        version: 0.1.0 
        helmRepoURL: ""
        chartName: "" #chart aname # optionnal
        values: 
            labels: {}
            annotations: {}
        valueFiles: 
            - /location/to/the/value/file/in/the/gitop/repo
        valueFilesGit: "giturl if the repo is not same as where the code is"
```

# Example of ow the applicationset will look like
```yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: application-todo
  labels: {} #auto generate using helper.tpl and also grab the global labels and also the dependency.service labels. substitute the repeating keys
  annotations: {} # auto generate using helper.tpl and also grab the global annotations and also the dependency.service annotations. substitute the repeating keys

spec:
  generators:
  - list:
      elements:
      {{- range $key, $value := .Values.dependencies }}
        - name: {{ $key }}
          chart: {{ $value.chart }} #optionnal so it can be have default ""
          version: {{ $value.version }}
          rawValues: {{ toYaml $value.Values | nindent 12 | trim }} # Renamed to avoid conflict with valueFiles
          valueFiles: {{ toYaml $value.ValueFiles | nindent 12 | trim }}
          # Pass the cluster label value from values.yaml to the template
          clusterLabelValue: {{ $value.targetClusterLabelValue }}
      {{- end }}
  - cluster:
      selector:
        matchLabels:
          # This label 'clusterName' should exist on your registered Argo CD clusters
          clusterName: '{{ .clusterLabelValue }}' # Dynamically uses the value from the list generator
  template:
    metadata:
      name: '{{.name}}-app'
    spec:
      project: '{{ .Values.global.project }}' # Or your specific Argo CD project
      sources:
        # Source 1: Helm Chart Repository
        - repoURL: .helmRepoURL or default to "" # Replace with your Helm repository URL
          chart: '{{.chart}}'
          targetRevision: '{{.version}}'
          helm:
            releaseName: "" # auto generated release name from the helper.tpl <assetid>-<appname>-<somethingelse>
            values: |
                {{.rawValues}} # Injects the raw values defined directly in values.yaml        
            valueFiles:
            {{- range $file := .valueFiles }}
                - $values/{{ $file }} # Prepend the 'values' ref to the file path
            {{- end }}
        # Source 2: Git Repository for ValueFiles
        - repoURL: .valueFilesGit or default "" # Replace with your Git repository URL
          targetRevision: HEAD # Or a specific branch/tag (e.g., main, v1.0.0)
          ref: values
      destination:
        name: '{{ .server }}' 
        namespace: {{ .Values.global.namespace }} # default will be default namespace
      syncPolicy:
        automated:
          prune: true
          selfHeal: true
        syncOptions:
          - CreateNamespace=true
        

```